---
layout: post
title:  "浅谈软件设计"
date:   2020-06-16 17:37:09 +0800
categories: jekyll update
---



# 什么是软件设计

![img](page/clip_image002.jpg)

![img](page/clip_image004.jpg)

![img](page/clip_image006.jpg)![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg)

![img](page/clip_image010.jpg)

软件设计是一个持续应用原则、模式和实践来改善软件结构和可读性的过程，它致力于保持软件系统在任何时间都尽可能简单、干净和富有表现力。设计原则和模式并不应该预先应用，而是在一次次的迭代中，用来让代码和代码表达的设计保持简单、干净和富有表现力。

 

# 单一职责原则SRP

就一个类而言，应该仅有一个引起它变化的原因。如果一个类承担的职责过多，则这些职责会耦合在一起，那么对于某个职责的变动会影响这个类完成其他类的能力，这会导致设计的脆弱性（改动一个功能影响其他的功能），当功能变化时，类的设计会遭到意想不到的破坏。注意——每个职责都将会是一个类变动的原因。

另外，测试驱动开发的原则会迫使我们在需求迭代之前就分离这些耦合的职责，如果无法进行职责分离，那么现有的设计的脆弱性和僵化性已经很明显了，此时可以考虑使用Facade或者Proxy模式进行现有软件设计的重构，进行职责的分离。

## 例子

![img](page/clip_image012.jpg)

如何分离？

## Facade模式

针对封装子系统，转化为高层接口，比如这里把Reader子系统进行了封装。

![img](page/clip_image014.jpg)

## Proxy模式

基于一致的接口进行封装，接口必须一致，只是对访问进行控制。

![img](page/clip_image016.jpg)

## 例子的解决

![img](page/clip_image018.jpg)

职责的分离往往带来的是类结构的拆分，一个类被拆成两个类这样的变更。

# 开放-封闭原则OCP

软件设计面对需求改变时应该保持稳定。能够描述出无数种可能性的、不会经常变动的类只有抽象类，因为抽象类描述的是一类规则，而不是具体的逻辑，而具体逻辑的扩展也往往基于抽象类描述的抽象规则。

对修改封闭本身建立在对变化性很好的抽象之上，只有很好地概括变化性的存在，并给出通用性的解决方案，才能达到对修改封闭、对扩展开放的软件设计目标。

![img](page/clip_image020.jpg)![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image022.jpg)

 

![img](page/clip_image024.jpg)![img](page/clip_image026.jpg)![img](page/clip_image028.jpg)

# 里氏替换原则LSP

如何设计并实现准确的is-a关系，如何准备描述继承关系？这里的关键应该是子类型需要在任何情况下替换掉它的父类型，这也是审视设计中is-a关系的准则之一。

审视一个特定is-a设计时，不能孤立看该解决方案是否自恰，而是应该把它放在整个使用场景之中看，因为is-a本身描述的是行为方式，是客户使用基类和使用子类之间行为的关联关系。

类本身有着其必定遵循的不变关系，称为类的不变式。一个类的不变式是通过每个行为来体现出来的，对于每个行为，其不变式会约束行为执行前满足前置条件，执行后满足后置条件，前置和后置条件会体现出类的不变式。对于一个合理的派生类，其行为的前置条件往往比基类的前置条件相等或更弱，而后置条件往往比基类的后置条件相等或更强。

即派生类只能接受基类的前置输入，并不能比基类对输入的要求更高，否则就不满足子类型需要在任何情况下替换掉它的父类型的里氏替换原则，而对于后置输出，派生类可以在基类的输出上做调整，但是应该满足基类的输出约束，否则也不能满足里氏替换原则。

对不符合里氏替换的软件结构调整的方法有提取公共部分形成公有的基类。

# 依赖倒置原则DIP

依赖倒置是开闭原则实现的重要途径之一，依赖倒置是指高层模块和底层模块应该共同依赖于抽象，细节也应该依赖于抽象的描述。

## 依赖

首先来看一下依赖和耦合的概念。

Rational Rose的帮助文档上是这样定义“依赖”关系的：“依赖描述了两个模型元素之间的关系，如果被依赖的模型元素发生变化就会影响到另一个模型元素。

Martin Fowler在《Reducing Coupling》一文中这样描述耦合：“如果改变程序的一个模块要求另一个模块同时发生变化，就认为这两个模块发生了耦合。”

从上面的定义可以看出：如果模块A调用模块B提供的方法，或访问模块B中的某些数据成员（当然，在面向对象开发中一般不提倡这样做），我们就认为模块A依赖于模块B，模块A和模块B之间发生了耦合。        

那么，依赖对于我们来说究竟是好事还是坏事呢？ 　　

由于人类的理解力有限，大多数人难以理解和把握过于复杂的系统。把软件系统划分成多个模块，可以有效控制模块的复杂度，使每个模块都易于理解和维护。但在这种情况下，模块之间就必须以某种方式交换信息，也就是必然要发生某种耦合关系。如果某个模块和其它模块没有任何关联（哪怕只是潜在的或隐含的依赖关系），我们就几乎可以断定，该模块不属于此软件系统，应该从系统中剔除。如果所有模块之间都没有任何耦合关系，其结果必然是：整个软件不过是多个互不相干的系统的简单堆积，对每个系统而言，所有功能还是要在一个模块中实现，这等于没有做任何模块的分解。        

因此，模块之间必定会有这样或那样的依赖关系，永远不要幻想消除所有依赖。但是，过强的耦合关系（如一个模块的变化会造成一个或多个其他模块也同时发生变化的依赖关系）会对软件系统的质量造成很大的危害。特别是当需求发生变化时，代码的维护成本将非常高。所以，我们必须想尽办法来控制和消解不必要的耦合，特别是那种会导致其它模块发生不可控变化的依赖关系。依赖倒置、控制反转、依赖注入等原则就是人们在和依赖关系进行艰苦卓绝的斗争过程中不断产生和发展起来的。

## 依赖关系的控制

人类对依赖关系的控制做过多次尝试，第一个尝试就是将程序接口和具体实现进行分离。通过这样的分离，一个程序可以替换同样接口的多个实现动态库，实现多种功能的替换。然而多个功能并不能同时并存并进行动态替换，只能每次重新启动程序时进行静态替换。

依赖倒置的原则则是第二次尝试，Robert Martin这样描述依赖倒置原则[Martin 1996]：

A. 上层模块不应该依赖于下层模块，它们共同依赖于一个抽象。

B. 抽象不能依赖于具象，具象依赖于抽象。

其含义是：为了消解两个模块间的依赖关系，应该在两个模块之间定义一个抽象接口，上层模块调用抽象接口定义的函数，下层模块实现该接口。

通过这样的方式，保持了高层和底层模块完全独立，相互之间没有直接的依赖关系，而是共同依赖于抽象接口。

## 依赖于抽象

依赖倒置是解耦模块间关联的重要原则，正如前面开闭原则中解释的对可变性部分的抽象描述，依赖倒置使得具体的可变逻辑依赖于了对可变性的抽象描述上，如下图。

![img](page/clip_image029.jpg)![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image030.jpg)

根据依赖于抽象的准则，所有的对象间依赖关系应该表现在抽象类和接口之间的依赖关系，而不是具体类与具体类之间的依赖关系。

![img](page/clip_image032.jpg)

## 公有接口所有权属于高层模块

依赖倒置除了倒置了高层依赖于底层的逻辑关系，还倒置了公有接口的归属权，表达高低层之间联系的接口属于高层模块，它随着高层模块的变动而变动，而不随着底层实现的变动而变动。

![img](page/clip_image034.jpg)

## 框架与依赖倒置

对于应用程序和类库之间的依赖关系，仅仅依赖倒置就已经足够了，而框架和应用程序之间的依赖关系则更为紧密，

框架和类库之间的区别在于：

“类库给用户提供了一系列可复用的类，这些类的设计都符合面向对象原则和模式。用户使用时，可以创建这些类的实例，或从这些类中继承出新的派生类，然后调用类中相应的功能。在这一过程中，类库总是被动地响应用户的调用请求。

“框架则会为某一特定目的实现一个基本的、可执行的架构。框架中已经包含了应用程序从启动到运行的主要流程，流程中那些无法预先确定的步骤留给用户来实现。程序运行时，框架系统自动调用用户实现的功能组件。这时，框架系统的行为是主动的。

我们可以说，类库是死的，而框架是活的。应用程序通过调用类库来完成特定的功能，而框架则通过调用应用程序来实现整个操作流程。框架是控制倒置原则的完美体现。框架本身需要通过回调函数/模板方法模式的方式动态调用应用程序的功能，这种“不要调用框架，让框架调用你”的特点完美地符合了依赖倒置的特点。

从某种意义上说，我们也可以把“控制反转”看作是“依赖倒置”的一个特例。**用模板方法模式实现的****“****控制反转****”****机制其实就是在框架系统和应用程序之间抽象出了一个描述所有算法步骤原型的接口类，框架系统依赖于该接口类定义并实现程序流程，应用程序依赖于该接口类提供具体算法步骤的实现，应用程序对框架系统的依赖被****“****倒置****”****为二者对抽象接口的依赖。**

 

控制反转也叫loC, 全称Inverse of Control。控制反转包括依赖注入(DI)和依赖查找(DL), 但我们大多数情况都认为loC就是DI。全称分别为: Dependency Injection和Dependency Lookup。loC的原理也叫做依赖倒置原理, 全称Dependency Inversion Principle。这里必须说明一下,loC是一种全新的设计模式。但Gof的23种设计模式中并没有loC是因为控制反转思想成熟较晚。

## 依赖注入-应用程序切断类间耦合的方法

![https://images.cnblogs.com/cnblogs_com/dotnetfresh/88.gif](page/clip_image035.gif)

从图 8中可以看出，虽然Reader和Writer接口隔离了“服务类”和具体的Reader和Writer类，使它们之间的耦合降到了最小。但当 “服务类”创建具体的Reader和Writer对象时，“服务类”还是和具体的Reader和Writer对象发生了依赖关系——图 8中用蓝色的虚线描述了这种依赖关系。
 　　在这种情况下，如何实例化具体的Reader和Writer类，同时又尽量减少服务类对它们的依赖，就是一个非常关键的问题了。如果服务类位于应用程序中，这一依赖关系对我们造成的影响还不算大。但当“服务类”位于需要独立发布的类库中，它的代码就不能随着应用程序的变化而改变了。

​       解决这一问题的方法是“依赖注入”，即切断“服务类”到具体的Reader和Writer类之间的依赖关系，**而是由应用程序来注入这一依赖关系**。

依赖注入的核心思想是： 　　

\1. 抽象接口隔离了使用者和实现之间的依赖关系，但创建具体实现类的实例对象仍会造成对于具体实现的依赖。 　　

\2. 采用依赖注入可以消除这种创建依赖性。使用依赖注入后，某些类完全是基于抽象接口编写而成的，这可以最大限度地适应需求的变化。

依赖注入有三种途径：

\1.     构造注入（在构造函数中传入依赖项）

\2.     方法注入（通过特定方法传入依赖项）

\3.     属性注入（公开特定属性直接更换依赖项）

# 接口隔离原则ISP

对于一个不是内聚的类而言，如果其接口间有着紧密的关系，无法进行单一职责的类结构分拆，那么可以考虑对类的接口进行接口分拆，即将一个胖类分解成多个职责单一的接口类的组合体。进行接口分拆和接口隔离的操作可以防止接口之间互相污染，也让类的结构更为清晰，分离接口往往就是划分目标用户群体，指明不同用户群体的用途。

接口分拆有委托分离接口和多继承两种方案，分别适应不同的面向对象编程语言。

比如单继承的面向对象语言，可以采用多个委托分离接口调用一个类的不同方法方式，而多继承的面向对象语言，则可以直接分拆不同用途的抽象类，然后使用多继承的方式指明一个类的多种用途。

# 参考内容

敏捷软件开发：原则、模式与实践

https://www.cnblogs.com/jingshihaisu/p/3739538.html

 

 

 